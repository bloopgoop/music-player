import { app, BrowserWindow, ipcMain } from "electron";
import fs from "fs";
import path from "path";
import nodeID3 from "node-id3";
import mime from "mime";
// @ts-ignore
import mp3Duration from "mp3-duration";
import connectDb from "./db/base";
import * as crud from "./db/crud";
import { Playlist, Song } from "./db/models";

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string;
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string;

// App directory
const app_dir = app.getPath("music") + "/simp";

// Database directory
const testdb = connectDb(app_dir + "/simplify.db");

crud.initializeTables(testdb);

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require("electron-squirrel-startup")) {
  app.quit();
}

let mainWindow: BrowserWindow;
const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    // frame: false,
    height: 600,
    width: 840,
    minHeight: 600,
    minWidth: 840,
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
    },
  });

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY);

  // Open the DevTools.
  mainWindow.webContents.openDevTools();
};

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on("ready", createWindow);

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit();
  }
});

app.on("activate", () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow();
  }
});

/**
 * Register a song to the database, add it to the "All songs" playlist
 * @param info.filePaths[] - list of file paths as strings
 */
ipcMain.on("register songs", async (event, info) => {
  const song_dir = app_dir + "/songs";
  if (!fs.existsSync(song_dir)) {
    fs.mkdirSync(song_dir, { recursive: true });
  }

  for (var i = 0; i < info.filePaths.length; i++) {
    const newFilePath = path.join(
      song_dir,
      info.filePaths[i].split("\\").pop()
    );
    fs.copyFile(info.filePaths[i], newFilePath, (err) => {
      if (err) {
        console.error(err);
        return;
      }
    });

    const tags = nodeID3.read(info.filePaths[i]);
    const duration = await mp3Duration(info.filePaths[i]);
    const songId = await crud.createSong(testdb, {
      path: newFilePath,
      image_mime: typeof tags.image === "string" ? undefined : tags.image.mime,
      image_buffer:
        typeof tags.image === "string"
          ? undefined
          : Buffer.from(tags.image.imageBuffer).toString("base64"),
      title: tags.title,
      artist: tags.artist,
      album: tags.album,
      genre: tags.genre,
      year: tags.year,
      lyrics: tags.unsynchronisedLyrics.text,
      listens: 0,
      duration: duration,
      date_added: new Date().toISOString(),
    });
    await crud.addSongToPlaylist(testdb, "All songs", songId);
  }
});

/**
 * Gets the audio data of a song in base64 format
 * @param id - song id
 * @returns - base64 audio data
 */
ipcMain.handle("get song audio", async (event, id: number) => {
  const path = await crud.getSongPathByID(testdb, id);
  const buffer = fs.readFileSync(path);
  return buffer.toString("base64");
});

/**
 * Get all song metadata in a playlist
 * @param playlistName - playlist name
 * @returns - list of song objects
 */
ipcMain.handle("get songs in playlist", async (event, playlistName: string) => {
  return await crud.getSongsInPlaylist(testdb, playlistName);
});

/**
 * Get metadata of a song
 * @param id - song id
 * @returns - song object
 */
ipcMain.handle("get song metadata", async (event, id: number) => {
  return await crud.getSongByID(testdb, id);
});

/**
 * Edit a song in the database
 * @param id - song id
 * @param args - song object
 * @returns - song name
 */
ipcMain.handle("edit song", async (event, id: number, args: any) => {
  const original_song = await crud.getSongByID(testdb, id);
  const imageBuffer = args.image
    ? fs.readFileSync(args.image).toString("base64")
    : undefined;
  const imageMime = args.image ? mime.getType(args.image) : undefined;
  const song = new Object({
    path: args.path ? args.path : original_song.path,
    title: args.title ? args.title : original_song.title,
    artist: args.artist ? args.artist : original_song.artist,
    album: args.album ? args.album : original_song.album,
    genre: args.genre ? args.genre : original_song.genre,
    year: args.year ? args.year : original_song.year,
    image_mime: imageMime ? imageMime : original_song.image_mime,
    image_buffer: imageBuffer ? imageBuffer : original_song.image_buffer,
    id: id,
  }) as Song;
  const songId = await crud.editSong(testdb, song);
  return songId;
});

/**
 * Get all songs in a queue
 * @param queue - list of song ids
 * @returns - list of song objects
 */
ipcMain.handle("get songs in queue", async (event, queue: number[]) => {
  const songs = [];
  for (var i = 0; i < queue.length; i++) {
    songs.push(await crud.getSongByID(testdb, queue[i]));
  }
  return songs;
});

/**
 * Create a new playlist
 * @return - new playlist object
 */
ipcMain.handle("create playlist", async (event) => {
  const playlistName = await crud.getUnusedPlaylistName(testdb);
  console.log("Creating playlist: " + playlistName);
  const id = await crud.createPlaylist(testdb, playlistName);
  const playlist = await crud.getPlaylistByID(testdb, id);
  event.sender.send(
    "recieve all playlists",
    await crud.getAllPlaylists(testdb)
  );
  return playlist;
});

/**
 * Get all playlists from the database
 * @returns - list of playlists
 */
ipcMain.handle("get all playlists", async (event) => {
  console.log("Getting all playlists");
  return await crud.getAllPlaylists(testdb);
});

/**
 * Get playlist information and all songs in the playlist
 * @param playlistName - playlist name
 * @returns - playlist object
 */
ipcMain.handle("get playlist", async (event, playlistName: string) => {
  return await crud.getPlaylistByName(testdb, playlistName);
});

/**
 * Delete a playlist from the database, send playlist update to renderer
 * @param id - playlist id
 */
ipcMain.handle("delete playlist", async (event, id: number) => {
  const playlistId = await crud.deletePlaylist(testdb, id);
  event.sender.send(
    "recieve all playlists",
    await crud.getAllPlaylists(testdb)
  );
  return playlistId;
});

/**
 * Edit a playlist in the database
 * @param args - playlist object
 * @returns - playlistname
 */
ipcMain.handle("edit playlist", async (event, args: any) => {
  console.log(args);
  const imageBuffer = args.imageFilePath
    ? fs.readFileSync(args.imageFilePath).toString("base64")
    : undefined;
  const imageMime = args.imageFilePath
    ? mime.getType(args.imageFilePath)
    : undefined;
  console.log(imageMime);
  const playlist = new Object({
    name: args.name,
    description: args.description,
    image_mime: imageMime,
    image_buffer: imageBuffer,
    id: args.id,
  }) as Playlist;
  const playlistName = await crud.editPlaylist(testdb, playlist);
  event.sender.send(
    "recieve all playlists",
    await crud.getAllPlaylists(testdb)
  );
  return playlistName;
});

/**
 * Add a song to a playlist
 * @param playlistName - playlist name
 * @param songId - song id
 */
ipcMain.handle(
  "add song to playlist",
  async (event, playlistName: string, songId: number) => {
    await crud.addSongToPlaylist(testdb, playlistName, songId);
  }
);

/**
 * Delete a song from a playlist
 * @param playlistName - playlist name
 * @param songId - song id
 */
ipcMain.handle(
  "delete song from playlist",
  async (event, playlistName: string, songId: number) => {
    await crud.deleteSongFromPlaylist(testdb, playlistName, songId);
    event.sender.send(
      "recieve playlist update",
      await crud.getSongsInPlaylist(testdb, playlistName)
    );
  }
);

/**
 * Get song ids given a playlist name
 * @param {string} playlistName
 * @returns {number[]}
 */
ipcMain.handle("get song ids", async (event, playlistName: string) => {
  return await crud.getSongIds(testdb, playlistName)
});
